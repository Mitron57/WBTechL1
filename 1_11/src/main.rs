use std::collections::HashMap;

// Можно сделать с верхней границей, хранить в качестве ключа пару (нижнее, верхнее значение)
// 
// Вариант 1: использовать не ассоциативный контейнер, 
// а просто Vec<Vec<f64>>, в качестве индекса будет результат целочисленного деления температуры на 10,
// если результат деления превышает размер массива, то расширить, пока размер массива не подойдет
// для данного индекса (Хоть и доступ будет быстрым, затраты по памяти будут большими)
// 
// Вариант 2: Отсортировать полученные данные, итерируясь по ним также узнавать, к какому отрезку относится
// данная температура и складывать в Vec<Vec<f64>>, здесь индекс уже ничего значить не будет, 
// границы мы будем узнавать как на 18 строчке моего кода.

fn main() {
    let data = [-25.4, -27.0, 13.0, 19.0, 15.5, 24.5, -21.0, 32.5, 30.0];
    let mut map: HashMap<_, Vec<_>> = HashMap::new();
    for elem in data {
        let low_bound = (elem as i64 / 10) * 10;
        let low_bound = if low_bound < 0 { low_bound - 10 } else { low_bound };
        if let Some(temps) = map.get_mut(&low_bound) {
            temps.push(elem);
        } else {
            map.insert(low_bound, vec![elem]);
        }
    }
    // Для красивого вывода, если последовательность отрезков не важна, 
    // то можно просто итерироваться по мапе
    let mut lower_bounds = map.keys().collect::<Vec<&i64>>();
    lower_bounds.sort();
    for low_bound in lower_bounds {
        println!("[{}..{}): {:?}", low_bound, low_bound + 10, map[low_bound]);
    }
}
